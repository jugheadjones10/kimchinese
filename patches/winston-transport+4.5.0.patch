diff --git a/node_modules/winston-transport/dist/index.js b/node_modules/winston-transport/dist/index.js
index fb2ff60..788ea38 100644
--- a/node_modules/winston-transport/dist/index.js
+++ b/node_modules/winston-transport/dist/index.js
@@ -1,9 +1,9 @@
-'use strict';
+"use strict";
 
-var util = require('util');
-var Writable = require('readable-stream/lib/_stream_writable.js');
+var util = require("util");
+var Writable = require("readable-stream/lib/_stream_writable.js");
 
-var _require = require('triple-beam'),
+var _require = require("triple-beam"),
     LEVEL = _require.LEVEL;
 
 /**
@@ -24,7 +24,10 @@ var TransportStream = module.exports = function TransportStream() {
 
   var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
 
-  Writable.call(this, { objectMode: true, highWaterMark: options.highWaterMark });
+  Writable.call(this, {
+    objectMode: true,
+    highWaterMark: options.highWaterMark
+  });
 
   this.format = options.format;
   this.level = options.level;
@@ -37,7 +40,7 @@ var TransportStream = module.exports = function TransportStream() {
   if (options.close) this.close = options.close;
 
   // Get the levels from the source we are piped from.
-  this.once('pipe', function (logger) {
+  this.once("pipe", function (logger) {
     // Remark (indexzero): this bookkeeping can only support multiple
     // Logger parents with the same `levels`. This comes into play in
     // the `winston.Container` code in which `container.add` takes
@@ -47,7 +50,7 @@ var TransportStream = module.exports = function TransportStream() {
   });
 
   // If and/or when the transport is removed from this instance
-  this.once('unpipe', function (src) {
+  this.once("unpipe", function (src) {
     // Remark (indexzero): this bookkeeping can only support multiple
     // Logger parents with the same `levels`. This comes into play in
     // the `winston.Container` code in which `container.add` takes
@@ -96,7 +99,9 @@ TransportStream.prototype._write = function _write(info, enc, callback) {
     // We trap(and re-throw) any errors generated by the user-provided format, but also
     // guarantee that the streams callback is invoked so that we can continue flowing.
     try {
+      console.log("Inside logger, before transformation by format", info);
       transformed = this.format.transform(Object.assign({}, info), this.format.options);
+      console.log("Inside logger, after transformation by format", info);
     } catch (err) {
       errState = err;
     }
@@ -212,4 +217,4 @@ TransportStream.prototype._nop = function _nop() {
 };
 
 // Expose legacy stream
-module.exports.LegacyTransportStream = require('./legacy');
\ No newline at end of file
+module.exports.LegacyTransportStream = require("./legacy");
\ No newline at end of file
diff --git a/node_modules/winston-transport/index.js b/node_modules/winston-transport/index.js
index 59e8421..447d32e 100644
--- a/node_modules/winston-transport/index.js
+++ b/node_modules/winston-transport/index.js
@@ -1,8 +1,8 @@
-'use strict';
+"use strict"
 
-const util = require('util');
-const Writable = require('readable-stream/lib/_stream_writable.js');
-const { LEVEL } = require('triple-beam');
+const util = require("util")
+const Writable = require("readable-stream/lib/_stream_writable.js")
+const { LEVEL } = require("triple-beam")
 
 /**
  * Constructor function for the TransportStream. This is the base prototype
@@ -15,48 +15,53 @@ const { LEVEL } = require('triple-beam');
  * creation
  * @param {Function} options.close - Called on "unpipe" from parent.
  */
-const TransportStream = module.exports = function TransportStream(options = {}) {
-  Writable.call(this, { objectMode: true, highWaterMark: options.highWaterMark });
-
-  this.format = options.format;
-  this.level = options.level;
-  this.handleExceptions = options.handleExceptions;
-  this.handleRejections = options.handleRejections;
-  this.silent = options.silent;
-
-  if (options.log) this.log = options.log;
-  if (options.logv) this.logv = options.logv;
-  if (options.close) this.close = options.close;
+const TransportStream = (module.exports = function TransportStream(
+  options = {}
+) {
+  Writable.call(this, {
+    objectMode: true,
+    highWaterMark: options.highWaterMark,
+  })
+
+  this.format = options.format
+  this.level = options.level
+  this.handleExceptions = options.handleExceptions
+  this.handleRejections = options.handleRejections
+  this.silent = options.silent
+
+  if (options.log) this.log = options.log
+  if (options.logv) this.logv = options.logv
+  if (options.close) this.close = options.close
 
   // Get the levels from the source we are piped from.
-  this.once('pipe', logger => {
+  this.once("pipe", (logger) => {
     // Remark (indexzero): this bookkeeping can only support multiple
     // Logger parents with the same `levels`. This comes into play in
     // the `winston.Container` code in which `container.add` takes
     // a fully realized set of options with pre-constructed TransportStreams.
-    this.levels = logger.levels;
-    this.parent = logger;
-  });
+    this.levels = logger.levels
+    this.parent = logger
+  })
 
   // If and/or when the transport is removed from this instance
-  this.once('unpipe', src => {
+  this.once("unpipe", (src) => {
     // Remark (indexzero): this bookkeeping can only support multiple
     // Logger parents with the same `levels`. This comes into play in
     // the `winston.Container` code in which `container.add` takes
     // a fully realized set of options with pre-constructed TransportStreams.
     if (src === this.parent) {
-      this.parent = null;
+      this.parent = null
       if (this.close) {
-        this.close();
+        this.close()
       }
     }
-  });
-};
+  })
+})
 
 /*
  * Inherit from Writeable using Node.js built-ins
  */
-util.inherits(TransportStream, Writable);
+util.inherits(TransportStream, Writable)
 
 /**
  * Writes the info object to our transport instance.
@@ -68,43 +73,48 @@ util.inherits(TransportStream, Writable);
  */
 TransportStream.prototype._write = function _write(info, enc, callback) {
   if (this.silent || (info.exception === true && !this.handleExceptions)) {
-    return callback(null);
+    return callback(null)
   }
 
   // Remark: This has to be handled in the base transport now because we
   // cannot conditionally write to our pipe targets as stream. We always
   // prefer any explicit level set on the Transport itself falling back to
   // any level set on the parent.
-  const level = this.level || (this.parent && this.parent.level);
+  const level = this.level || (this.parent && this.parent.level)
 
   if (!level || this.levels[level] >= this.levels[info[LEVEL]]) {
     if (info && !this.format) {
-      return this.log(info, callback);
+      return this.log(info, callback)
     }
 
-    let errState;
-    let transformed;
+    let errState
+    let transformed
 
     // We trap(and re-throw) any errors generated by the user-provided format, but also
     // guarantee that the streams callback is invoked so that we can continue flowing.
     try {
-      transformed = this.format.transform(Object.assign({}, info), this.format.options);
+      console.log("Inside logger, before transformation by format", info)
+      transformed = this.format.transform(
+        Object.assign({}, info),
+        this.format.options
+      )
+      console.log("Inside logger, after transformation by format", info)
     } catch (err) {
-      errState = err;
+      errState = err
     }
 
     if (errState || !transformed) {
       // eslint-disable-next-line callback-return
-      callback();
-      if (errState) throw errState;
-      return;
+      callback()
+      if (errState) throw errState
+      return
     }
 
-    return this.log(transformed, callback);
+    return this.log(transformed, callback)
   }
-  this._writableState.sync = false;
-  return callback(null);
-};
+  this._writableState.sync = false
+  return callback(null)
+}
 
 /**
  * Writes the batch of info objects (i.e. "object chunks") to our transport
@@ -116,27 +126,27 @@ TransportStream.prototype._write = function _write(info, enc, callback) {
  */
 TransportStream.prototype._writev = function _writev(chunks, callback) {
   if (this.logv) {
-    const infos = chunks.filter(this._accept, this);
+    const infos = chunks.filter(this._accept, this)
     if (!infos.length) {
-      return callback(null);
+      return callback(null)
     }
 
     // Remark (indexzero): from a performance perspective if Transport
     // implementers do choose to implement logv should we make it their
     // responsibility to invoke their format?
-    return this.logv(infos, callback);
+    return this.logv(infos, callback)
   }
 
   for (let i = 0; i < chunks.length; i++) {
-    if (!this._accept(chunks[i])) continue;
+    if (!this._accept(chunks[i])) continue
 
     if (chunks[i].chunk && !this.format) {
-      this.log(chunks[i].chunk, chunks[i].callback);
-      continue;
+      this.log(chunks[i].chunk, chunks[i].callback)
+      continue
     }
 
-    let errState;
-    let transformed;
+    let errState
+    let transformed
 
     // We trap(and re-throw) any errors generated by the user-provided format, but also
     // guarantee that the streams callback is invoked so that we can continue flowing.
@@ -144,26 +154,26 @@ TransportStream.prototype._writev = function _writev(chunks, callback) {
       transformed = this.format.transform(
         Object.assign({}, chunks[i].chunk),
         this.format.options
-      );
+      )
     } catch (err) {
-      errState = err;
+      errState = err
     }
 
     if (errState || !transformed) {
       // eslint-disable-next-line callback-return
-      chunks[i].callback();
+      chunks[i].callback()
       if (errState) {
         // eslint-disable-next-line callback-return
-        callback(null);
-        throw errState;
+        callback(null)
+        throw errState
       }
     } else {
-      this.log(transformed, chunks[i].callback);
+      this.log(transformed, chunks[i].callback)
     }
   }
 
-  return callback(null);
-};
+  return callback(null)
+}
 
 /**
  * Predicate function that returns true if the specfied `info` on the
@@ -175,14 +185,14 @@ TransportStream.prototype._writev = function _writev(chunks, callback) {
  * logged.
  */
 TransportStream.prototype._accept = function _accept(write) {
-  const info = write.chunk;
+  const info = write.chunk
   if (this.silent) {
-    return false;
+    return false
   }
 
   // We always prefer any explicit level set on the Transport itself
   // falling back to any level set on the parent.
-  const level = this.level || (this.parent && this.parent.level);
+  const level = this.level || (this.parent && this.parent.level)
 
   // Immediately check the average case: log level filtering.
   if (
@@ -194,12 +204,12 @@ TransportStream.prototype._accept = function _accept(write) {
     // 1. { handleExceptions: true }: all `info` objects are valid
     // 2. { exception: false }: accepted by all transports.
     if (this.handleExceptions || info.exception !== true) {
-      return true;
+      return true
     }
   }
 
-  return false;
-};
+  return false
+}
 
 /**
  * _nop is short for "No operation"
@@ -207,9 +217,8 @@ TransportStream.prototype._accept = function _accept(write) {
  */
 TransportStream.prototype._nop = function _nop() {
   // eslint-disable-next-line no-undefined
-  return void undefined;
-};
-
+  return void undefined
+}
 
 // Expose legacy stream
-module.exports.LegacyTransportStream = require('./legacy');
+module.exports.LegacyTransportStream = require("./legacy")
diff --git a/node_modules/winston-transport/package-lock.json b/node_modules/winston-transport/package-lock.json
new file mode 100644
index 0000000..a047c38
Binary files /dev/null and b/node_modules/winston-transport/package-lock.json differ
